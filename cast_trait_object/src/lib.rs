//! This crate offers functionality for casting between trait objects using only
//! safe Rust and no platform specific code. If you want to downcast to concrete
//! types instead of other trait objects then this crate can't help you, instead
//! use something like the [`downcast-rs`] crate.
//!
//! <!-- Generate README.md using `cargo readme --no-license > README.md` -->
//! <!-- Generate documentation using `cargo +nightly doc --features docs` -->
//!
//! # Usage
//!
//! You should use the [`DynCast`] trait in trait bounds or as a supertrait and
//! then do casts using the methods provided by the [`DynCastExt`] trait. The
//! [`DynCast`] trait takes a type parameter that should be a "config" type
//! generated by the [`create_dyn_cast_config`] macro, this type defines from
//! which trait and to which trait a cast is made. Types that need to allow casting
//! to meet the [`DynCast`] trait bound can then implement it via the
//! [`impl_dyn_cast`] macro.
//!
//! # Examples
//!
//! ```
//! use cast_trait_object::{create_dyn_cast_config, impl_dyn_cast, DynCast, DynCastExt};
//!
//! create_dyn_cast_config!(SuperToSubCast = Super => Sub);
//! create_dyn_cast_config!(SuperUpcast = Super => Super);
//! trait Super: DynCast<SuperToSubCast> + DynCast<SuperUpcast> {}
//! trait Sub: Super {}
//!
//! struct Foo;
//! impl Super for Foo {}
//! impl Sub for Foo {}
//! impl_dyn_cast!(Foo as Super => Sub, Super);
//!
//! let foo: &dyn Super = &Foo;
//! // Casting to a sub trait is fallible (the error allows us to keep using the
//! // `dyn Super` trait object if we want which can be important if we are casting
//! // movable types like `Box<dyn Trait>`):
//! let foo: &dyn Sub = foo.dyn_cast().ok().unwrap();
//! // Upcasting to a supertrait is infallible:
//! let foo /*: &dyn Super*/ = foo.dyn_upcast::<dyn Super>();
//! ```
//!
//! When implementing the [`DynCast`] trait via the [`impl_dyn_cast`] macro you
//! can also list the created "config" types instead of the source and target
//! traits:
//!
//! ```
//!# use cast_trait_object::{create_dyn_cast_config, impl_dyn_cast, DynCast, DynCastExt};
//!# //
//!# create_dyn_cast_config!(SuperToSubCast = Super => Sub);
//!# create_dyn_cast_config!(SuperUpcast = Super => Super);
//!# trait Super: DynCast<SuperToSubCast> + DynCast<SuperUpcast> {}
//!# trait Sub: Super {}
//!# //
//!# struct Foo;
//!# impl Super for Foo {}
//!# impl Sub for Foo {}
//! impl_dyn_cast!(Foo => SuperToSubCast, SuperUpcast);
//!# //
//!# let foo: &dyn Super = &Foo;
//!# let foo: &dyn Sub = foo.dyn_cast().ok().unwrap();
//!# let foo /*: &dyn Super*/ = foo.dyn_upcast::<dyn Super>();
//! ```
//!
//! If the `proc-macros` feature is enabled (which it is by default) we can also
//! use procedural attribute macros to write a little bit less boilerplate:
//!
//! ```
//!# use cast_trait_object::*;
//!# fn main() { inner::some_fn(); }
//!# mod inner {
//!# pub fn some_fn() {
//! use cast_trait_object::{dyn_cast, dyn_upcast, DynCastExt};
//!
//! #[dyn_cast(Sub)]
//! #[dyn_upcast]
//! trait Super {}
//! trait Sub: Super {}
//!
//! struct Foo;
//! #[dyn_cast(Sub)]
//! #[dyn_upcast]
//! impl Super for Foo {}
//! impl Sub for Foo {}
//!# //
//!# let foo: &dyn Super = &Foo;
//!# let foo: &dyn Sub = foo.dyn_cast().ok().unwrap();
//!# let foo /*: &dyn Super*/ = foo.dyn_upcast::<dyn Super>();
//!# }}
//! ```
//!
//! Note that `#[dyn_upcast]` does the same as `#[dyn_cast(Super)]` but it is a bit
//! clearer about intentions:
//!
//! ```
//!# use cast_trait_object::*;
//!# fn main() { inner::some_fn(); }
//!# mod inner {
//!# pub fn some_fn() {
//! use cast_trait_object::{dyn_cast, DynCastExt};
//!
//! #[dyn_cast(Super, Sub)]
//! trait Super {}
//! trait Sub: Super {}
//!
//! struct Foo;
//! #[dyn_cast(Super, Sub)]
//! impl Super for Foo {}
//! impl Sub for Foo {}
//!
//!# let foo: &dyn Super = &Foo;
//!# let foo: &dyn Sub = foo.dyn_cast().ok().unwrap();
//! // Upcasting still works:
//! let foo /*: &dyn Super*/ = foo.dyn_upcast::<dyn Super>();
//!# }}
//! ```
//!
//! # How it works
//!
//! ## How is the conversion preformed
//!
//! Using the [`DynCast`] trait as a supertraits adds a couple of extra methods
//! to a trait object's vtable. These methods all essentially take a pointer to
//! the type and returns a new fat pointer which points to the wanted vtable.
//! There are a couple of methods since we need to generate one for each type of
//! trait object, so one for each of `&dyn Trait`, `&mut dyn Trait`,
//! `Box<dyn Trait>`, `Rc<dyn Trait>` and `Arc<dyn Trait>`. Note that these methods
//! are entirely safe Rust code, this crate doesn't use or generate any unsafe
//! code at all.
//!
//! The [`DynCastExt`] trait then abstracts over the different types of trait
//! objects so that when a call is made using the [dyn_cast](DynCastExt::dyn_cast)
//! method the compiler can inline that static method call to the correct method
//! on the trait object.
//!
//! ## Why "config" types
//!
//! We have to generate "config" types since we need to uniquely identify each
//! [`DynCast`] supertrait based on which trait it is casting from and into.
//! Originally this was just done using two type parameters on the trait, something
//! like `DynCast<dyn Super, dyn Sub>`, but that caused compile errors when they were
//! used as a supertrait of one of the mentioned traits. So now the traits are
//! "hidden" as associated types on a generated "config" type. To make this "config"
//! type more ergonomic we also implement a [`GetDynCastConfig`] trait to easily
//! go from the source trait and target trait to a "config" type via something
//! like `<dyn Source as GetDynCastConfig<dyn Target>>::Config`. This allows
//! the macros ([`impl_dyn_cast`], [`dyn_cast`] and [`dyn_upcast`]) to take traits
//! as arguments instead of "config" types, it also makes type inference work for
//! the [`DynCastExt`] trait.
//!
//! ## How does the macros know if a type implements a "target" trait or not
//!
//! When a type implementing [`DynCast`] for a specific config and therefore
//! source to target trait cast the generated code must choose if the cast is
//! going to succeed or not. We want to return `Ok(value as &dyn Target)` if
//! the type implements the `Target` trait and `Err(value as &dyn Source)` if
//! it doesn't.
//!
//! We can use a clever hack to determine if the type implements the `Target`
//! trait. See the [`impls`](https://crates.io/crates/impls) crate's
//! [github page](https://github.com/nvzqz/impls#how-it-works) for how this hack
//! works. In short the hack allows getting a const bool that is `true` if a type
//! implements a trait and `false` otherwise.
//!
//! So we could generate something like:
//!
//! ```rust,compile_fail
//! trait Source {}
//! trait Target {}
//!
//! struct Foo;
//! impl Source for Foo {}
//!
//! const IMPLEMENTS_TRAIT: bool = false /* Really should use impls!(Foo: Target) */;
//!
//! impl Foo {
//!     fn cast(&self) -> Result<&dyn Target, &dyn Source> {
//!         if IMPLEMENTS_TRAIT {
//!             // Compile time error here:
//!             Ok(self)
//!           //   ^^^^ the trait `Target` is not implemented for `Foo`
//!         } else {
//!             Err(self)
//!         }
//!     }
//! }
//! ```
//!
//! But it fails to compile even though we will never actually run the code that
//! coerces `Foo` to `Target`. So since coercing a type to a trait it doesn't
//! implement is a type error we need to use our const value to affect the types
//! in the generated code somehow.
//!
//! This can be done by using the const value as a length of an array to get a
//! type (note that a bool can be converted to a `usize`). Once we have a type we
//! can use Rust's powerful type system to choose different methods based on our
//! initial value:
//!
//! ```
//! struct Choose<T>(T);
//! impl Choose<[(); 0]> {
//!     fn foo(arg: usize) -> &'static str { "false" }
//! }
//! impl Choose<[(); 1]> {
//!     fn foo(arg: String, arg2: bool) -> bool { true }
//! }
//! // These methods have the same name but are actually totally different methods:
//! let foo: &'static str = Choose::<[(); 0]>::foo(1);
//! let foo: bool = Choose::<[(); 1]>::foo("some text".to_string(), false);
//! ```
//!
//! or using a trait:
//!
//! ```
//! trait AltChoose { type Result; }
//! struct A;
//! impl A {
//!     fn foo(arg: usize) -> &'static str { "false" }
//! }
//! impl AltChoose for [(); 0] { type Result = A; }
//! struct B;
//! impl B {
//!     fn foo(arg: String, arg2: bool) -> bool { true }
//! }
//! impl AltChoose for [(); 1] { type Result = B; }
//!
//! // These methods have the same name but are actually totally different methods:
//! let foo: &'static str = <[(); 0] as AltChoose>::Result::foo(1);
//! let foo: bool = <[(); 1] as AltChoose>::Result::foo("some text".to_string(), false);
//! ```
//!
//! So the [`impl_dyn_cast`] macro works by generate a const `bool` that indicates
//! if a type implements a trait and then uses that const value with one of the
//! above hacks to determine which helper method to call when implementing the
//! [`DynCast`] trait. This way the generated code doesn't call the helper method
//! that preform the coercion to the `Target` trait unless the type actually
//! implements it.
//!
//! # Alternatives
//!
//! The [`intertrait`] crate offers similar functionality to this crate but has
//! a totally different implementation, at least as of [`intertrait`] version
//! `0.2.0`. It uses the [`linkme`] crate to create a registry of [`std::any::Any`]
//! type ids for types that can be cast into a certain trait object. This means
//! it probably has some runtime overhead when it looks up a cast function in
//! the global registry using a [`TypeId`]. It also means that it can't work on
//! all platforms since the [`linkme`] crate needs to offer support for them. This
//! is a limitation that this crate doesn't have.
//!
//! The [`traitcast`] crate works similar to [`intertrait`] in that it has a
//! global registry that is keyed with [`TypeId`]s. But it differs in that it
//! uses the [`inventory`] crate to build the registry instead of the [`linkme`]
//! crate. The [`inventory`] crate uses the [`ctor`] crate to run some code before
//! `main`, something that is generally discouraged and this is something that
//! [`intertrait`] actually mentions as an advantage to its approach.
//!
//! The [`traitcast_core`] library allow for a more low level API that doesn't
//! depend on a global registry and therefore also doesn't depend on a crate like
//! [`linkme`] or [`inventory`] that needs platform specific support. Instead it
//! requires that you explicitly create a registry and register all your types
//! and their casts with it.
//!
//! The [`downcast-rs`] crate offers downcasting to concrete types but not
//! directly casting from one trait object to another trait object. So it has a
//! different use case and both it and this crate could be useful in the same
//! project.
//!
//! # References
//!
//! The following GutHub issue [Clean up pseudo-downcasting from VpnProvider supertrait to subtraits with better solution · Issue #21 · jamesmcm/vopono](https://github.com/jamesmcm/vopono/issues/21)
//! inspired this library.
//!
//! # License
//!
//! This project is released under either:
//!
//! - [MIT License](https://github.com/Lej77/cast_trait_object/blob/master/LICENSE-MIT)
//! - [Apache License (Version 2.0)](https://github.com/Lej77/cast_trait_object/blob/master/LICENSE-APACHE)
//!
//! at your choosing.
//!
//! [`std::any::Any`]: https://doc.rust-lang.org/std/any/trait.Any.html
//! [`TypeId`]: https://doc.rust-lang.org/std/any/struct.TypeId.html
//! [`downcast-rs`]: https://crates.io/crates/downcast-rs
//! [`intertrait`]: https://crates.io/crates/intertrait
//! [`traitcast`]: https://crates.io/crates/traitcast
//! [`traitcast_core`]: https://crates.io/crates/traitcast_core
//! [`linkme`]: https://crates.io/crates/linkme
//! [`inventory`]: https://crates.io/crates/inventory
//! [`ctor`]: https://crates.io/crates/ctor
#![no_std]
#![forbid(unsafe_code)]
// Warnings and docs:
#![warn(clippy::all)]
#![deny(intra_doc_link_resolution_failure)]
#![cfg_attr(feature = "docs", feature(doc_cfg))]
#![warn(missing_debug_implementations, missing_docs, rust_2018_idioms)]
#![doc(test(
    no_crate_inject,
    attr(
        deny(warnings, rust_2018_idioms),
        allow(unused_extern_crates, unused_variables)
    )
))]

/// Activate some code only when a certain config is met. Show the required config in the documentation.
///
/// To ensure `rustfmt` works on the enclosed code be sure to invoke this macro in a functional style.
/// Also if the code contains references to `self` then use the `impl Self { /* code... */ }` invocation.
macro_rules! cfg_with_docs {
    ($feature:meta, { $(impl Self { $($code:tt)* })* }) => {
        $(
            #[cfg($feature)]
            #[cfg_attr(feature = "docs", doc(cfg($feature)))]
            $($code)*
        )*
    };
    ($feature:meta, $({$($code:tt)*}),*) => {
        $(
            #[cfg($feature)]
            #[cfg_attr(feature = "docs", doc(cfg($feature)))]
            $($code)*
        )*
    };
}

#[cfg(feature = "alloc")]
extern crate alloc;

#[cfg(feature = "alloc")]
use alloc::{boxed::Box, rc::Rc, sync::Arc};

cfg_with_docs!(
    feature = "proc-macros",
    {
        /// Allow upcast from a trait to one of its supertraits. This can be used
        /// on traits or on types. For types you need to specify the path to the super
        /// trait inside the parenthesis after the macro name like so:
        /// `#[dyn_upcast(SuperTrait)]` while for traits don't need to specify anything
        /// `#[dyn_upcast]`.
        ///
        /// # Examples
        ///
        /// ```
        /// use cast_trait_object::*;
        ///# fn main() {
        ///
        /// #[dyn_upcast]
        /// trait Super {}
        ///
        /// trait Sub: Super {}
        ///
        /// #[dyn_upcast(Super)]
        /// struct Foo;
        /// impl Super for Foo {}
        /// impl Sub for Foo {}
        ///
        /// // We can now cast from one trait object to another:
        /// let foo: &dyn Sub = &Foo;
        /// let foo: &dyn Super = foo.dyn_upcast();
        ///# }
        /// ```
        ///
        /// The macro can also be applied to a trait implementation (`impl Trait for Type`)
        /// instead of directly on a type:
        ///
        /// ```
        ///# use cast_trait_object::*;
        ///# fn main() {
        ///#
        ///# #[dyn_upcast]
        ///# trait Super {}
        ///#
        ///# trait Sub: Super {}
        ///#
        ///# struct Foo;
        /// #[dyn_upcast]
        /// impl Super for Foo {}
        ///# impl Sub for Foo {}
        ///#
        ///# // We can now cast from one trait object to another:
        ///# let foo: &dyn Sub = &Foo;
        ///# let foo: &dyn Super = foo.dyn_upcast();
        ///# }
        /// ```
        pub use cast_trait_object_macros::dyn_upcast;
    },
    {
        /// Allow attempting to cast a trait object to another trait object. This can be
        /// used on traits or on types. For types you need to specify the path to the
        /// "source" trait inside the parenthesis after the macro name like so:
        /// `#[dyn_cast(SourceTrait => TargetTrait)]`, while for traits you only need to
        /// specify the target trait: `#[dyn_cast(TargetTrait)]`.
        /// # Examples
        ///
        /// ```
        /// use cast_trait_object::*;
        ///# fn main() {
        ///
        /// #[dyn_cast(Sub)]
        /// trait Super {}
        ///
        /// trait Sub: Super {}
        ///
        /// #[dyn_cast(Super => Sub)]
        /// struct Foo;
        /// impl Super for Foo {}
        /// impl Sub for Foo {}
        ///
        /// // We can now attempt casting between trait objects:
        /// let foo: &dyn Super = &Foo;
        /// let foo: &dyn Sub = foo.dyn_cast().ok().unwrap();
        ///# }
        /// ```
        ///
        /// The macro can also be applied to a trait implementation (`impl Trait for Type`)
        /// instead of directly on a type:
        ///
        /// ```
        ///# use cast_trait_object::*;
        ///# fn main() {
        ///#
        ///# #[dyn_cast(Sub)]
        ///# trait Super {}
        ///#
        ///# trait Sub: Super {}
        ///#
        ///# struct Foo;
        /// #[dyn_cast(Sub)]
        /// impl Super for Foo {}
        ///# impl Sub for Foo {}
        ///#
        ///# // We can now attempt casting between trait objects:
        ///# let foo: &dyn Super = &Foo;
        ///# let foo: &dyn Sub = foo.dyn_cast().ok().unwrap();
        ///# }
        /// ```
        pub use cast_trait_object_macros::dyn_cast;
    }
);

/// Used by macros to determine if a type can be coerced to a "config" type's
/// target trait.
///
/// If a config type implements `DynCastConfigTargetTest<T>` for a type `T` then
/// that type can be coerced to the trait defined by `<C as DynCastConfig>::Target`.
///
/// This is used by the [`impl_dyn_cast`] macro to determine if it should generate
/// code that coerces a type to the target trait or to the source trait.
pub trait DynCastConfigTargetTest<C: ?Sized> {}

/// Get a [`DynCastConfig`] type for a source trait that casts to a target trait `T`.
///
/// This is used by the [`impl_dyn_cast`] macro to allow specifying only the traits
/// that are being cast from and to instead of a concrete config type that implements
/// the [`DynCastConfig`] trait.
///
/// This is also needed for the implementation of the [`DynCastExt`] trait to ensure
/// that type inference works so that it is ergonomic to use.
pub trait GetDynCastConfig<T: ?Sized> {
    /// A config type that casts from the `Self` trait to the trait `T`.
    type Config: DynCastConfig<Target = T, Source = Self>;
}

/// Specifies the trait that we are casting from and the trait we are casting to.
///
/// The reason we need a "config" type instead of just specifying the source
/// and target traits as type parameters in the [`DynCast`] trait is that the
/// compiler would error out it certain situations due to it detecting "cycles".
/// "Hiding" the source and target traits as associated types prevent this from
/// happening and allows using the [`DynCast`] trait as a supertrait of the
/// source trait from which we perform a cast.
pub trait DynCastConfig {
    /// The trait we are casting to.
    type Target: ?Sized;
    /// The trait we are casting from and that we want back if the cast failed.
    type Source: ?Sized;
}

/// Cast a trait object for trait  `F` to a trait object of the trait `T`.
///
/// This trait is object safe and provides methods to convert from one fat pointer
/// to another. This can be used as a supertrait or via trait bounds to allow
/// casting between two different trait objects. But for usage it is more ergonomic
/// to use the methods that are provided by the [`DynCastExt`] trait than to call
/// the methods on this trait directly.
pub trait DynCast<T: DynCastConfig> {
    /// Cast a shared reference of this trait object to another trait object.
    fn dyn_cast_ref(&self) -> Result<&T::Target, &T::Source>;
    /// Cast a mutable/unique reference of this trait object to another trait object.
    fn dyn_cast_mut(&mut self) -> Result<&mut T::Target, &mut T::Source>;

    cfg_with_docs!(feature = "alloc", {
        impl Self {
            /// Cast a boxed trait object to another trait object.
            fn dyn_cast_boxed(self: Box<Self>) -> Result<Box<T::Target>, Box<T::Source>>;
        }
        impl Self {
            /// Cast a reference counted trait object to another trait object.
            fn dyn_cast_rc(self: Rc<Self>) -> Result<Rc<T::Target>, Rc<T::Source>>;
        }
        impl Self {
            /// Cast an atomically reference counted trait object to another trait object.
            fn dyn_cast_arc(self: Arc<Self>) -> Result<Arc<T::Target>, Arc<T::Source>>;
        }
    });
}

/// Get the [`DynCastConfig`] type used to cast trait `F` to trait `T`.
type GetConfig<F, T> = <F as GetDynCastConfig<T>>::Config;
/// Gets the type that is returned if a cast fails when casting type `A` to the trait `T`.
type GetSource<A, T> = <A as DynCastExtHelper<T>>::Source;
/// Gets the wanted type when casting type `A` to the trait `T`.
type GetTarget<A, T> = <A as DynCastExtHelper<T>>::Target;

/// Simplifies the use of the [`DynCast`] trait by abstracting away the difference
/// between different ways of storing trait objects.
pub trait DynCastExt {
    /// Use this to cast from one trait object type to another.
    ///
    /// The `T` type parameter should be the target trait, not the target type.
    ///
    /// # Examples
    ///
    /// ```
    /// use cast_trait_object::{create_dyn_cast_config, impl_dyn_cast, DynCast, DynCastExt};
    ///
    /// create_dyn_cast_config!(SuperToSubCast = Super => Sub);
    /// trait Super: DynCast<SuperToSubCast> {}
    /// trait Sub: Super {}
    ///
    /// struct Foo;
    /// impl Super for Foo {}
    /// impl Sub for Foo {}
    /// impl_dyn_cast!(Foo as Super => Sub);
    ///
    /// let foo: &dyn Super = &Foo;
    /// // Casting to a sub trait is fallible (the error allows us to keep using the
    /// // `dyn Super` trait object if we want which can be important if we are casting
    /// // movable types like `Box<dyn Trait>`):
    /// let foo: &dyn Sub = foo.dyn_cast().ok().unwrap();
    /// ```
    fn dyn_cast<T: ?Sized>(self) -> Result<Self::Target, Self::Source>
    where
        Self: DynCastExtHelper<T>;

    /// Use this to upcast a trait to one of its supertraits.
    ///
    /// The `T` type parameter should be the wanted supertrait.
    ///
    /// This works by using a cast where both the source and target is the wanted
    /// trait.
    ///
    /// # Examples
    ///
    /// ```
    /// use cast_trait_object::{create_dyn_cast_config, impl_dyn_cast, DynCast, DynCastExt};
    ///
    /// create_dyn_cast_config!(SuperUpcast = Super => Super);
    /// trait Super: DynCast<SuperUpcast> {}
    /// trait Sub: Super {}
    ///
    /// struct Foo;
    /// impl Super for Foo {}
    /// impl Sub for Foo {}
    /// impl_dyn_cast!(Foo as Super => Super);
    ///
    /// let foo: &dyn Sub = &Foo;
    /// // Upcasting to a supertrait is infallible (so we don't need any error handling):
    /// let foo /*: &dyn Super*/ = foo.dyn_upcast::<dyn Super>();
    /// ```
    fn dyn_upcast<T: ?Sized>(self) -> Self::Target
    where
        Self: DynCastExtAdvHelper<T, T, Source = GetAdvTarget<Self, T, T>>;

    /// Use this to cast from one trait object type to another. This method is more
    /// customizable than the [`dyn_cast`](DynCastExt::dyn_cast) method. Here you can also specify the
    /// "source" trait from which the cast is defined. This can for example allow
    /// using casts from a supertrait of the current trait object.
    ///
    /// The `F` Type parameter should be the trait that is returned if the cast
    /// fails.
    /// The `T` type parameter should be the target trait, not the target type.
    ///
    /// # Examples
    ///
    /// ```
    /// use cast_trait_object::{create_dyn_cast_config, impl_dyn_cast, DynCast, DynCastExt};
    ///
    /// create_dyn_cast_config!(SuperToSub1Cast = Super => Sub1);
    /// create_dyn_cast_config!(SuperToSub2Cast = Super => Sub2);
    /// trait Super: DynCast<SuperToSub1Cast> + DynCast<SuperToSub2Cast> {}
    /// trait Sub1: Super {}
    /// trait Sub2: Super {}
    ///
    /// struct Foo;
    /// impl Super for Foo {}
    /// impl Sub1 for Foo {}
    /// impl Sub2 for Foo {}
    /// impl_dyn_cast!(Foo as Super => Sub1, Sub2);
    ///
    /// let foo: &dyn Sub1 = &Foo;
    /// let foo /*: &dyn Sub2 */ = foo.dyn_cast_adv::<dyn Super, dyn Sub2>().ok().unwrap();
    /// ```
    ///
    /// In the above example we need to use [`dyn_cast_adv`](DynCastExt::dyn_cast_adv)
    /// instead of [`dyn_cast`](DynCastExt::dyn_cast) since we don't want to use our
    /// current trait object as the source of the cast, we want to use one of our super
    /// traits. The code `foo.dyn_cast::<dyn Sub2>()` would be the same as
    /// `foo.dyn_cast_adv::<dyn Sub1, dyn Sub2>()` and would fail to compile.
    fn dyn_cast_adv<F: ?Sized, T: ?Sized>(self) -> Result<Self::Target, Self::Source>
    where
        Self: DynCastExtAdvHelper<F, T>;

    /// Use this to cast from one trait object type to another. With this method
    /// the type parameter is a config type that uniquely specifies which cast
    /// should be preformed.
    ///
    /// The `C` type parameter should be the config type that is used to preform
    /// the cast.
    ///
    /// This method can do the same things as the [`dyn_cast_adv`](DynCastExt::dyn_cast_adv)
    /// method but allows specifying the source and target traits via a "config"
    /// type instead of using trait names.
    ///
    /// # Examples
    ///
    /// ```
    /// use cast_trait_object::{create_dyn_cast_config, impl_dyn_cast, DynCast, DynCastExt};
    ///
    /// create_dyn_cast_config!(SuperToSub1Cast = Super => Sub1);
    /// create_dyn_cast_config!(SuperToSub2Cast = Super => Sub2);
    /// trait Super: DynCast<SuperToSub1Cast> + DynCast<SuperToSub2Cast> {}
    /// trait Sub1: Super {}
    /// trait Sub2: Super {}
    ///
    /// struct Foo;
    /// impl Super for Foo {}
    /// impl Sub1 for Foo {}
    /// impl Sub2 for Foo {}
    /// impl_dyn_cast!(Foo as Super => Sub1, Sub2);
    ///
    /// let foo: &dyn Sub1 = &Foo;
    /// let foo /*: &dyn Sub2 */ = foo.dyn_cast_with_config::<SuperToSub2Cast>().ok().unwrap();
    /// ```
    fn dyn_cast_with_config<C: DynCastConfig>(self) -> Result<Self::Target, Self::Source>
    where
        Self: DynCastExtAdvHelper<C::Source, C::Target>;
}
impl<A> DynCastExt for A {
    fn dyn_cast<T: ?Sized>(self) -> Result<GetTarget<Self, T>, GetSource<Self, T>>
    where
        Self: DynCastExtHelper<T>,
    {
        self._dyn_cast()
    }
    fn dyn_upcast<T: ?Sized>(self) -> GetAdvTarget<Self, T, T>
    where
        Self: DynCastExtAdvHelper<T, T, Source = GetAdvTarget<Self, T, T>>,
    {
        match self._dyn_cast() {
            Ok(v) => v,
            Err(e) => e,
        }
    }
    fn dyn_cast_adv<F: ?Sized, T: ?Sized>(self) -> GetAdvCastResult<Self, F, T>
    where
        Self: DynCastExtAdvHelper<F, T>,
    {
        self._dyn_cast()
    }
    fn dyn_cast_with_config<C: DynCastConfig>(self) -> GetAdvCastResult<Self, C::Source, C::Target>
    where
        Self: DynCastExtAdvHelper<C::Source, C::Target>,
    {
        self._dyn_cast()
    }
}

/// Used to implement [`DynCastExt`].
pub trait DynCastExtHelper<T: ?Sized> {
    /// The wanted trait object that is returned if the cast succeeded.
    type Target;
    /// The original trait object that is returned if the cast failed.
    type Source;
    /// The [`DynCastConfig`] that is used to preform the conversion.
    type Config;

    /// This method is used to cast from one trait object type to another.
    fn _dyn_cast(self) -> Result<Self::Target, Self::Source>;
}
impl<'a, T, F> DynCastExtHelper<T> for &'a F
where
    T: ?Sized + 'static,
    F: ?Sized + 'static + DynCast<GetConfig<F, T>> + GetDynCastConfig<T>,
{
    type Target = &'a T;
    type Source = &'a F;
    type Config = GetConfig<F, T>;

    fn _dyn_cast(self) -> Result<Self::Target, Self::Source> {
        DynCast::dyn_cast_ref(self)
    }
}
impl<'a, T, F> DynCastExtHelper<T> for &'a mut F
where
    T: ?Sized + 'static,
    F: ?Sized + 'static + DynCast<GetConfig<F, T>> + GetDynCastConfig<T>,
{
    type Target = &'a mut T;
    type Source = &'a mut F;
    type Config = GetConfig<F, T>;

    fn _dyn_cast(self) -> Result<Self::Target, Self::Source> {
        DynCast::dyn_cast_mut(self)
    }
}
cfg_with_docs!(
    feature = "alloc",
    {
        impl<'a, T, F> DynCastExtHelper<T> for Box<F>
        where
            T: ?Sized + 'static,
            F: ?Sized + 'static + DynCast<GetConfig<F, T>> + GetDynCastConfig<T>,
        {
            type Target = Box<T>;
            type Source = Box<F>;
            type Config = GetConfig<F, T>;

            fn _dyn_cast(self) -> Result<Self::Target, Self::Source> {
                DynCast::dyn_cast_boxed(self)
            }
        }
    },
    {
        impl<'a, T, F> DynCastExtHelper<T> for Rc<F>
        where
            T: ?Sized + 'static,
            F: ?Sized + 'static + DynCast<GetConfig<F, T>> + GetDynCastConfig<T>,
        {
            type Target = Rc<T>;
            type Source = Rc<F>;
            type Config = GetConfig<F, T>;

            fn _dyn_cast(self) -> Result<Self::Target, Self::Source> {
                DynCast::dyn_cast_rc(self)
            }
        }
    },
    {
        impl<'a, T, F> DynCastExtHelper<T> for Arc<F>
        where
            T: ?Sized + 'static,
            F: ?Sized + 'static + DynCast<GetConfig<F, T>> + GetDynCastConfig<T>,
        {
            type Target = Arc<T>;
            type Source = Arc<F>;
            type Config = GetConfig<F, T>;

            fn _dyn_cast(self) -> Result<Self::Target, Self::Source> {
                DynCast::dyn_cast_arc(self)
            }
        }
    }
);

/// Gets the type that is returned if a cast fails when casting type `A` to the trait `T`.
type GetAdvSource<A, F, T> = <A as DynCastExtAdvHelper<F, T>>::Source;
/// Gets the wanted type when casting type `A` to the trait `T`.
type GetAdvTarget<A, F, T> = <A as DynCastExtAdvHelper<F, T>>::Target;
type GetAdvCastResult<A, F, T> = Result<GetAdvTarget<A, F, T>, GetAdvSource<A, F, T>>;

/// Used to implement [`DynCastExt`].
pub trait DynCastExtAdvHelper<F: ?Sized, T: ?Sized> {
    /// The wanted trait object that is returned if the cast succeeded.
    type Target;
    /// The original trait object that is returned if the cast failed.
    type Source;

    /// This method is used to cast from one trait object type to another.
    fn _dyn_cast(self) -> Result<Self::Target, Self::Source>;
}
impl<'a, T, F, A> DynCastExtAdvHelper<F, T> for &'a A
where
    T: ?Sized + 'static,
    F: ?Sized + 'static + GetDynCastConfig<T>,
    A: ?Sized + 'static + DynCast<GetConfig<F, T>>,
{
    type Target = &'a T;
    type Source = &'a F;

    fn _dyn_cast(self) -> Result<Self::Target, Self::Source> {
        DynCast::dyn_cast_ref(self)
    }
}
impl<'a, T, F, A> DynCastExtAdvHelper<F, T> for &'a mut A
where
    T: ?Sized + 'static,
    F: ?Sized + 'static + GetDynCastConfig<T>,
    A: ?Sized + 'static + DynCast<GetConfig<F, T>>,
{
    type Target = &'a mut T;
    type Source = &'a mut F;

    fn _dyn_cast(self) -> Result<Self::Target, Self::Source> {
        DynCast::dyn_cast_mut(self)
    }
}
cfg_with_docs!(
    feature = "alloc",
    {
        impl<'a, T, F, A> DynCastExtAdvHelper<F, T> for Box<A>
        where
            T: ?Sized + 'static,
            F: ?Sized + 'static + GetDynCastConfig<T>,
            A: ?Sized + 'static + DynCast<GetConfig<F, T>>,
        {
            type Target = Box<T>;
            type Source = Box<F>;

            fn _dyn_cast(self) -> Result<Self::Target, Self::Source> {
                DynCast::dyn_cast_boxed(self)
            }
        }
    },
    {
        impl<'a, T, F, A> DynCastExtAdvHelper<F, T> for Rc<A>
        where
            T: ?Sized + 'static,
            F: ?Sized + 'static + GetDynCastConfig<T>,
            A: ?Sized + 'static + DynCast<GetConfig<F, T>>,
        {
            type Target = Rc<T>;
            type Source = Rc<F>;

            fn _dyn_cast(self) -> Result<Self::Target, Self::Source> {
                DynCast::dyn_cast_rc(self)
            }
        }
    },
    {
        impl<'a, T, F, A> DynCastExtAdvHelper<F, T> for Arc<A>
        where
            T: ?Sized + 'static,
            F: ?Sized + 'static + GetDynCastConfig<T>,
            A: ?Sized + 'static + DynCast<GetConfig<F, T>>,
        {
            type Target = Arc<T>;
            type Source = Arc<F>;

            fn _dyn_cast(self) -> Result<Self::Target, Self::Source> {
                DynCast::dyn_cast_arc(self)
            }
        }
    }
);

/// This wrapper helps the [`impl_provider_cast`] macro to implement the
/// [`ProviderCast`] trait.
#[allow(non_camel_case_types, missing_debug_implementations)]
#[doc(hidden)]
pub struct __impl_dyn_cast_wrapper<T>(T);
// The implementation for when a trait is NOT implemented for a type.
#[allow(missing_docs)]
impl<T> __impl_dyn_cast_wrapper<[T; 0]> {
    pub fn cast<U, E, F: FnOnce(T) -> E>(value: T, f: F) -> Result<U, E> {
        Err(f(value))
    }
}
// The implementation for when a trait is implemented. We could require more from
// the type via more strict trait bounds in the where clauses.
#[allow(missing_docs)]
impl<T> __impl_dyn_cast_wrapper<[T; 1]> {
    pub fn cast<U, E, F: FnOnce(T) -> U>(value: T, f: F) -> Result<U, E> {
        Ok(f(value))
    }
}

/// Implement the [`DynCast`] trait for a type to cast from a specific trait object
/// to a specified different trait object.
#[cfg(not(feature = "alloc"))]
#[macro_export]
macro_rules! impl_dyn_cast {
    ($self_type:ty as $source_trait:path => $($target_trait:path),*) => {
        $crate::impl_dyn_cast! {
            $self_type => $(<dyn $source_trait + 'static as $crate::GetDynCastConfig<dyn $target_trait + 'static>>::Config),*
        }
    };
    ($self_type:ty => $($config_type:ty),*) => {
        $(
            const _: fn() = || {
                const __DOES_IMPLEMENT_TARGET_TRAIT: usize = {
                    // See the [`impls`](https://crates.io/crates/impls) crate's github
                    // [page](https://github.com/nvzqz/impls#how-it-works) for how
                    // this hack works.

                    // Fallback trait for to all types to default to `false`.
                    trait __NotTrait {
                        const __DETERMINE_IF_TYPE_IMPLEMENTS_TRAIT: bool = false;
                    }
                    impl<T> __NotTrait for T {}

                    // Concrete wrapper type where `__DETERMINE_IF_TYPE_IMPLEMENTS_TRAIT` becomes `true` if `T: Trait`.
                    struct __HasTrait<T>(core::marker::PhantomData<T>);

                    impl<T: $crate::DynCastConfigTargetTest<$self_type>> __HasTrait<T> {
                        // Because this is implemented directly on `__HasTrait`, it has priority over
                        // the `__NotTrait` trait impl.
                        //
                        // Note: this is a *totally different* associated constant from that in
                        // `__NotTrait`. This does not specialize the `__NotTrait` trait impl on
                        // `__HasTrait`.
                        const __DETERMINE_IF_TYPE_IMPLEMENTS_TRAIT: bool = true;
                    }
                    // `true` becomes `1` and `false` becomes `0`:
                    __HasTrait::<$config_type>::__DETERMINE_IF_TYPE_IMPLEMENTS_TRAIT as usize
                };

                impl $crate::DynCast<$config_type> for $self_type {
                    fn dyn_cast_ref(
                        &self,
                    ) -> ::core::result::Result<
                        &<$config_type as $crate::DynCastConfig>::Target,
                        &<$config_type as $crate::DynCastConfig>::Source,
                    > {
                        $crate::__impl_dyn_cast_wrapper::<[_; __DOES_IMPLEMENT_TARGET_TRAIT]>::cast::<
                            &<$config_type as $crate::DynCastConfig>::Target,
                            &<$config_type as $crate::DynCastConfig>::Source,
                            _,
                        >(self, |v| v)
                    }

                    fn dyn_cast_mut(
                        &mut self,
                    ) -> ::core::result::Result<
                        &mut <$config_type as $crate::DynCastConfig>::Target,
                        &mut <$config_type as $crate::DynCastConfig>::Source,
                    > {
                        $crate::__impl_dyn_cast_wrapper::<[_; __DOES_IMPLEMENT_TARGET_TRAIT]>::cast::<
                            &mut <$config_type as $crate::DynCastConfig>::Target,
                            &mut <$config_type as $crate::DynCastConfig>::Source,
                            _,
                        >(self, |v| v)
                    }
                }
            };
        )*
    };
}

/// Implement the [`DynCast`] trait for a type to cast from a specific trait object
/// to a specified different trait object.
#[cfg(feature = "alloc")]
#[macro_export]
macro_rules! impl_dyn_cast {
    ($self_type:ty as $source_trait:path => $($target_trait:path),*) => {
        $crate::impl_dyn_cast! {
            $self_type => $(<dyn $source_trait + 'static as $crate::GetDynCastConfig<dyn $target_trait + 'static>>::Config),*
        }
    };
    ($self_type:ty => $($config_type:ty),*) => {
        $(
            const _: fn() = || {
                extern crate alloc;

                const __DOES_IMPLEMENT_TARGET_TRAIT: usize = {
                    // See the [`impls`](https://crates.io/crates/impls) crate's github
                    // [page](https://github.com/nvzqz/impls#how-it-works) for how
                    // this hack works.

                    // Fallback trait for to all types to default to `false`.
                    trait __NotTrait {
                        const __DETERMINE_IF_TYPE_IMPLEMENTS_TRAIT: bool = false;
                    }
                    impl<T> __NotTrait for T {}

                    // Concrete wrapper type where `__DETERMINE_IF_TYPE_IMPLEMENTS_TRAIT` becomes `true` if `T: Trait`.
                    struct __HasTrait<T>(core::marker::PhantomData<T>);

                    impl<T: $crate::DynCastConfigTargetTest<$self_type>> __HasTrait<T> {
                        // Because this is implemented directly on `__HasTrait`, it has priority over
                        // the `__NotTrait` trait impl.
                        //
                        // Note: this is a *totally different* associated constant from that in
                        // `__NotTrait`. This does not specialize the `__NotTrait` trait impl on
                        // `__HasTrait`.
                        const __DETERMINE_IF_TYPE_IMPLEMENTS_TRAIT: bool = true;
                    }
                    // `true` becomes `1` and `false` becomes `0`:
                    __HasTrait::<$config_type>::__DETERMINE_IF_TYPE_IMPLEMENTS_TRAIT as usize
                };

                impl $crate::DynCast<$config_type> for $self_type {
                    fn dyn_cast_ref(
                        &self,
                    ) -> ::core::result::Result<
                        &<$config_type as $crate::DynCastConfig>::Target,
                        &<$config_type as $crate::DynCastConfig>::Source,
                    > {
                        $crate::__impl_dyn_cast_wrapper::<[_; __DOES_IMPLEMENT_TARGET_TRAIT]>::cast::<
                            &<$config_type as $crate::DynCastConfig>::Target,
                            &<$config_type as $crate::DynCastConfig>::Source,
                            _,
                        >(self, |v| v)
                    }

                    fn dyn_cast_mut(
                        &mut self,
                    ) -> ::core::result::Result<
                        &mut <$config_type as $crate::DynCastConfig>::Target,
                        &mut <$config_type as $crate::DynCastConfig>::Source,
                    > {
                        $crate::__impl_dyn_cast_wrapper::<[_; __DOES_IMPLEMENT_TARGET_TRAIT]>::cast::<
                            &mut <$config_type as $crate::DynCastConfig>::Target,
                            &mut <$config_type as $crate::DynCastConfig>::Source,
                            _,
                        >(self, |v| v)
                    }

                    fn dyn_cast_boxed(
                        self: alloc::boxed::Box<Self>,
                    ) -> ::core::result::Result<
                        alloc::boxed::Box<<$config_type as $crate::DynCastConfig>::Target>,
                        alloc::boxed::Box<<$config_type as $crate::DynCastConfig>::Source>,
                    > {
                        $crate::__impl_dyn_cast_wrapper::<[_; __DOES_IMPLEMENT_TARGET_TRAIT]>::cast::<
                            alloc::boxed::Box<<$config_type as $crate::DynCastConfig>::Target>,
                            alloc::boxed::Box<<$config_type as $crate::DynCastConfig>::Source>,
                            _,
                        >(self, |v| v)
                    }

                    fn dyn_cast_rc(
                        self: alloc::rc::Rc<Self>,
                    ) -> ::core::result::Result<
                        alloc::rc::Rc<<$config_type as $crate::DynCastConfig>::Target>,
                        alloc::rc::Rc<<$config_type as $crate::DynCastConfig>::Source>,
                    > {
                        $crate::__impl_dyn_cast_wrapper::<[_; __DOES_IMPLEMENT_TARGET_TRAIT]>::cast::<
                            alloc::rc::Rc<<$config_type as $crate::DynCastConfig>::Target>,
                            alloc::rc::Rc<<$config_type as $crate::DynCastConfig>::Source>,
                            _,
                        >(self, |v| v)
                    }

                    fn dyn_cast_arc(
                        self: alloc::sync::Arc<Self>,
                    ) -> ::core::result::Result<
                        alloc::sync::Arc<<$config_type as $crate::DynCastConfig>::Target>,
                        alloc::sync::Arc<<$config_type as $crate::DynCastConfig>::Source>,
                    > {
                        $crate::__impl_dyn_cast_wrapper::<[_; __DOES_IMPLEMENT_TARGET_TRAIT]>::cast::<
                            alloc::sync::Arc<<$config_type as $crate::DynCastConfig>::Target>,
                            alloc::sync::Arc<<$config_type as $crate::DynCastConfig>::Source>,
                            _,
                        >(self, |v| v)
                    }
                }
            };
        )*
    };
}

/// Create a new config type that implements [`DynCastConfig`]. If you need more
/// control over the generated config type then use the [`impl_dyn_cast_config`]
/// macro instead.
#[macro_export]
macro_rules! create_dyn_cast_config {
    ($(#[$attr:meta])* $config_vis:vis $config_name:ident = $source_trait:path => $target_trait:path) => {
        $(#[$attr])*
        $config_vis struct $config_name;
        $crate::impl_dyn_cast_config!($config_name = $source_trait => $target_trait);
    };
}

/// Implements [`DynCastConfig`], [`DynCastConfigTargetTest`] and
/// [`GetDynCastConfig`] for a config type.
#[macro_export]
macro_rules! impl_dyn_cast_config {
    ($config_type:ty = $source_trait:path => $target_trait:path) => {
        impl $crate::DynCastConfig for $config_type {
            type Target = dyn $target_trait;
            type Source = dyn $source_trait;
        }
        impl<T> $crate::DynCastConfigTargetTest<T> for $config_type
        where
            T: ?Sized + $target_trait
        {}
        impl $crate::GetDynCastConfig<dyn $target_trait> for dyn $source_trait {
            type Config = $config_type;
        }
    };
}

#[cfg(test)]
mod tests {
    create_dyn_cast_config!(
        /// Can have attributes on the generated config struct.
        #[derive(Clone)]
        SuperConfig = Super => Sub
    );
    trait Super: super::DynCast<SuperConfig> {}
    trait Sub: Super {}

    struct TestSuper;
    impl Super for TestSuper {}
    impl_dyn_cast!(TestSuper => SuperConfig);

    struct TestSub;
    impl Super for TestSub {}
    impl Sub for TestSub {}
    impl_dyn_cast! {TestSub as Super => Sub}

    /// Check so that dyn_cast correctly emits code on error (this ensures better
    /// error messages)
    #[allow(dead_code)]
    fn check_fallback() {
        struct T;
        impl T {
            // #[crate::dyn_cast]
            fn test(self) {}
        }
        T.test();
    }

    #[cfg(feature = "proc-macros")]
    #[allow(dead_code)]
    pub mod with_macros {
        use crate::*;

        #[dyn_cast(Sub)]
        #[dyn_upcast]
        trait Super {}
        trait Sub: Super {}

        #[dyn_cast(Super => Sub)]
        #[dyn_upcast(Super)]
        struct TestSuper;
        impl Super for TestSuper {}

        #[dyn_cast(Super => Sub)]
        #[dyn_upcast(Super)]
        struct TestSub;
        impl Super for TestSub {}
        impl Sub for TestSub {}
    }
}
